---
layout:     post
title: Vue跨域请求踩坑全纪录
subtitle:   "我是如何从vue-resource跨域坑中一步步爬上来的"
date:       2018-04-20
author:     dxw
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - 前端开发-Vue
---


## 前言
在web开发中，出现跨域请求是一件非常常见的问题，每一个web开发者都曾经历或正在经历着解决此问题的各种酸甜苦辣。网上资料提供的解决方案其实也五花八门，数不胜数。运气好的话也许找到的第一个解决方案，就能分分钟搞定，运气不好的时候估计要折腾半天，尝试N种姿势。就比如我......

前两天在公司项目中就遇到一个跨域问题，折腾了一个下午加一个晚上才搞定，期间尝试了一只手都数不过来的方法。工程是以vue作为前端框架，vue-resource作为网络请求插件，完成和服务器的数据交互。开发中在调用某一个获取信息的接口中报跨域请求错误。下面就列出自己的排查和解决过程，中间有什么分析错误的地方，或者思路不对的地方，大神可以指出。




<p id = "build"></p>
---

## 正文

#### 什么是跨域请求？
广义的跨域是指一个域下的文档或脚本试图去请求另一个域下的资源,包括

1. 资源跳转： A链接、重定向、表单提交;
2. 资源嵌入： `<link>、<script>、<img>、<frame>`等dom标签，还有样式中`background:url()、@font-face()`等文件外链;
3. 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等;

其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。

**什么是同源策略？**

同源策略`/SOP（Same origin policy）`是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
同源策略限制以下几种行为：

1. `Cookie、LocalStorage` 和 `IndexDB` 无法读取;
2. `DOM` 和 Js对象无法获得;
3. `AJAX` 请求不能发送;

而我们通常说的协议，端口，域名任一不同就会出现跨域请求其实可以归为以下几类：


<font color=#ff0000 >http</font>://www.abc.com/index.html 访问 <font color=#ff0000 >https</font>://www.abc.com/index.html (协议不同造成跨域）

http://www.abc.com/index.html 访问 http://www.abc.com<font color=#ff0000 >:8081</font>/index.html (端口不同造成跨域）

http://www.<font color=#ff0000 >abc</font>abc.com/index.html 访问 http://www.<font color=#ff0000 >def</font>.com/index.html (主域名不同造成跨域）

http://<font color=#ff0000 >abc</font>.abc.com/index.html 访问 http://<font color=#ff0000 >def</font>.abc.com/index.html (子域名不同造成跨域）


#### 我遇到的跨域问题
123464

#### 我是如何解决的？
在开发环境中出现跨域问题，其实最有效的是对服务端进行配置。若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。比如这样设置：

```
/*
 * 导入包：import javax.servlet.http.HttpServletResponse;
 * 接口参数中定义：HttpServletResponse response
 */
// 允许跨域访问的域名：*号代表允许所有域名跨域访问
response.setHeader("Access-Control-Allow-Origin", *); 

```
当然，我们在碰到这个跨域问题的时候，一开始就已经和后端小伙伴沟通好，早就设置了`Access-Control-Allow-Origin= *`。遗憾的是，这样设置没有生效，跨域问题仍然存在，要不然也不会有这篇blog的诞生了。后台小伙伴自己在尝试其它解决方案的时候，我也在查找各种从前端解决跨域的各种办法，并做出以下几种尝试。

###### 第一种: proxyTable

`proxytable`是`vuejs-templates`官方唯一提到的有关跨域方面的解决方案，也就是`vue-cli`的使用的模板插件里的config文件里有一个参数叫`proxyTable`,官方文档点[这里](https://vuejs-templates.github.io/webpack/proxy.html)。这个参数主要是一个地址映射表，你可以通过设置将复杂的url简化，例如我们要请求的地址是`http://jsonplaceholder.typicode.com`，可以按照如下设置：

```
proxyTable: {
   '/api': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
    }
}
```
这样我们在写url的时候，只用写成`/api `就可以代表`http://jsonplaceholder.typicode.com`。
那么又是如何解决跨域问题的呢？其实在上面的'api'的参数里有一个changeOrigin参数，接收一个布尔值，如果设置为true,那么本地会虚拟一个服务端接收你的请求并代你发送该请求，这样就不会有跨域问题了，当然这只适用于开发环境,正式环境需要切回去。然而当我设置之后，跨域问题并没有解决。


###### 第二种 jsonp
由于我调试的那个接口，也就出出现关于问题的接口正好是get请求。而jsonp据说是只支持get请求，那不妨拿来试试。
vue中使用jsonp需要用到vue-jsonp插件，

1. 执行命令：
`npm install vue-jsonp --save`


2. src/main.js中添加：

	```
	import VueJsonp from 'vue-jsonp'
	Vue.use(VueJsonp)
	```
3. 组件中使用：

	如果使用的是vue-resource的话，不需要执行上面的1和2 操作。vue-resource中本身就支持`jsonp(url, [options])`
		
	```
	this.$http.jsonp("apiurl",{params:{name:'a'}  
	                            }).then(resp=>{  
	                                console.log(resp.data.s);  
	                            },response => {  
	                                console.log("发送失败"+response.status+","+response.statusText);  
	                            });  
	})
	```
	然而最终也是失败告终，也是报跨域错误。
###### 第三种
123464
###### 第四种
123464
###### 第五种
123464
#### 总结
123464


---




