---
layout:     post
title: 葵花宝典之GCD篇
subtitle:   "GCD常用API说明和Demo演示"
date:       2018-03-13
author:     dxw
header-img: img/post-bg-gcd.jpg
catalog: true
tags:
    - iOS
---


## 前言

各路大神对GCD的原理解析和使用方法网上到处都是,可以轻松搜索到。那为什么我还要自己动手写一篇所谓的"葵花宝典"呢？本篇文章主要是普及了一些基础知识的概念，例如队列、线程、异步同步的区别。搞懂这些才是弄明白GCD的条件。然后搜集了GCD的绝大部分的api，包括不常用的。配上demo和代码实例，更容易理解GCD的应用场景和实现目的。

[点击此处下载demo](https://github.com/MrTung/GCD_Demo)  


## 基础概念
  
####   关于GCD：
  
    (1)是基于c语言的底层api
    (2)用block定义任务，使用起来非常灵活便捷
    (3)GCD会自动利用更多的CPU内核（比如双核、四核）
    (4)GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）
    (5)程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码
    
####   关于进程：

    正在进行中的程序被称为进程，负责程序运行的内存分配;每一个进程都有自己独立的虚拟内存空间；

####   关于线程：

    线程是进程中一个独立的执行路径(控制单元);一个进程中至少包含一条线程，即主线程。
  
####   关于队列：
队列用来存放任务，一种符合 FIFO（先进先出）原则的数据结构，线程的创建和回收不需要程序员操作，由队列负责。
    
    串行队列：队列中的任务只会顺序执行，一个任务执行完毕后，再执行下一个任务
    并发队列：队列中的多个任务并发（同时）执行,而且无法确定任务的执行顺序　　  　
    全局队列：是系统开发的，直接拿过来用就可以；与并行队列类似，但调试时，无法确认操作所在队列
    主队列：  每一个应用程序对应唯一一个主队列，是gcd中自带的一种特殊的串行队列，直接获取即可。放在主队列中的任务，都会在主线程中执行。在多线程开发中，使用主队列更新UI。

#### 关于操作：
    dispatch_async 异步操作，在新的线程中执行任务，具备开启新线程的能力(不是百分百开启新线程，会取决于任务所在队列类型)，会并发执行，无法确定任务的执行顺序；
    dispatch_sync  同步操作，在当前线程中执行任务，不具备开启新线程的能力，会依次顺序执行；

* 图例：
 ![](https://ws1.sinaimg.cn/large/006tNc79gy1fp6pp1knyxj30zk0chgmp.jpg)
   
 ![](https://ws3.sinaimg.cn/large/006tNc79gy1fp6pljr4g6j31080yktbi.jpg)

## 使用姿势

#### 分为两步:

第一步：创建一个队列;

第二步：将任务放到队列中；

#### 三个关键点：

第一点：任务内容；

第二点：队列类别；

第三点：操作(追加)姿势；

## 队列和任务

#### 1. 获取队列：

GCD中大体可以分为三种队列：

* 串行队列:
`dispatch_queue_t queue = dispatch_queue_create("com.test.testQueue", DISPATCH_QUEUE_SERIAL);`

* 并发队列:
	* 一般并发队列
`dispatch_queue_t queue = dispatch_queue_create("com.test.testQueue", DISPATCH_QUEUE_CONCURRENT);`
	* 全局并发队列可以作为普通并发队列来使用
`dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);`

* 主队列:
`dispatch_queue_t queue = dispatch_get_main_queue();`

#### 2. 操作(追加)方式：

* 同步执行任务创建方法
```
dispatch_sync(queue, ^{
    NSLog(@"我是任务");
});
```
* 异步执行任务创建方法
```
dispatch_async(queue, ^{
     NSLog(@"我是任务");
});
```

#### 3. 队列 + 任务：

##### 3.1   队列 + 任务的六种组合

看到这里你不难发现,GCD 提供了同步执行任务的创建方法`dispatch_sync`和异步执行任务创建方法`dispatch_async`,配合上述的三种队列形式（串行队列、并发队列、主队列)，那么就会存在六种不同的多线程使用方法，如下：

*   同步执行 & 并发队列 : 不新建线程，在当前线程中顺序执行
*   异步执行 & 并发队列 : 新建多个新线程，线程会复用，无序执行
*   同步执行 & 串行队列 : 在当前线程中顺序执行
*   异步执行 & 串行队列 : 新建一条新的线程，在该线程中顺序执行
*   异步执行 & 主队列   : 不新建线程，在主线程中顺序执行
*   同步执行 & 主队列（在主线程中会crash): 主线程中会产生死锁


![](https://ws1.sinaimg.cn/large/006tNc79gy1fpa1h50ozjj30vs09gaao.jpg)

##### 3.2   各种组合的使用方法

###### 同步执行 & 并发队列：

```
-(void)syncAndConcurrentqueue{
    
     NSLog(@"----start-----当前线程---%@",[NSThread currentThread]);
    
    //下面提供两种并发队列的获取方式，其运行结果无差别，所以归为了一类，你可以自由选择
    dispatch_queue_t queue = dispatch_queue_create("com.test.testQueue", DISPATCH_QUEUE_CONCURRENT);
    
    // 全局并发队列
    //    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    // 第一个任务
    dispatch_sync(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第一个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第二个任务
    dispatch_sync(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第二个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第三个任务
    dispatch_sync(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第三个任务---当前线程%@",[NSThread currentThread]);
    });
    
    NSLog(@"----end-----当前线程---%@",[NSThread currentThread]);
 }
```

* 输出结果：

![](https://ws4.sinaimg.cn/large/006tNc79gy1fpa1hjyzm5j31e4050myy.jpg)

* 总结：只会在当前线程中依次执行任务，不会开启新线程，执行完一个任务，再执行下一个任务,按照1>2>3顺序执行，遵循FIFO原则。


###### 异步执行 & 并发队列：

```
-(void)asyncAndConcurrentqueue{
    
    NSLog(@"----start-----当前线程---%@",[NSThread currentThread]);

    //下面提供两种并发队列的获取方式，其运行结果无差别，所以归为了一类，你可以自由选择
    
    //dispatch_queue_t queue = dispatch_queue_create("com.test.testQueue", DISPATCH_QUEUE_CONCURRENT);
    
    // 全局并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    // 第一个任务
    dispatch_async(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第一个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第二个任务
    dispatch_async(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第二个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第三个任务
    dispatch_async(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第三个任务---当前线程%@",[NSThread currentThread]);
    });
    
    NSLog(@"----end-----当前线程---%@",[NSThread currentThread]);

}

```
* 输出结果：

 ![](https://ws2.sinaimg.cn/large/006tNc79gy1fpa1hvkwehj31ey05cjtb.jpg)
 
* 总结：从log中可以发现,系统另外开启了3个线程，并且任务是同时执行的,并不是按照1>2>3顺序执行。所以异步+并发队列具备开启新线程的能力,且并发队列可开启多个线程，同时执行多个任务。

###### 同步执行 & 串行队列：

```
-(void)syncAndSerialqueue{
    NSLog(@"----start-----当前线程---%@",[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_queue_create("com.test.testQueue", DISPATCH_QUEUE_SERIAL);
    
    // 第一个任务
    dispatch_sync(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第一个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第二个任务
    dispatch_sync(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第二个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第三个任务
    dispatch_sync(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第三个任务---当前线程%@",[NSThread currentThread]);
    });
    
    NSLog(@"----end-----当前线程---%@",[NSThread currentThread]);

}

```
* 输出结果：

![](https://ws1.sinaimg.cn/large/006tNc79gy1fpa1i33ifdj31eu056q4u.jpg)

* 总结：只会在当前线程中依次执行任务，不会开启新线程，执行完一个任务，再执行下一个任务,按照1>2>3顺序执行，遵循FIFO原则。

###### 异步执行 & 串行队列：

```
-(void)asyncAndSerialqueue{
    NSLog(@"----start-----当前线程---%@",[NSThread currentThread]);
    
    dispatch_queue_t queue = dispatch_queue_create("com.test.testQueue", DISPATCH_QUEUE_SERIAL);
    
    // 第一个任务
    dispatch_async(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第一个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第二个任务
    dispatch_async(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第二个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第三个任务
    dispatch_async(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第三个任务---当前线程%@",[NSThread currentThread]);
    });
    
    NSLog(@"----end-----当前线程---%@",[NSThread currentThread]);
    
}
```
* 输出结果：
 ![](https://ws3.sinaimg.cn/large/006tNc79gy1fpa1ia4yh7j31fw056wge.jpg)
 
* 总结:开启了一条新线程，异步执行具备开启新线程的能力,因为是串行队列所以只开启一个线程，在该线程中执行完一个任务，再执行下一个任务,按照1>2>3顺序执行，遵循FIFO原则。

###### 异步执行 & 主队列：

```
-(void)asyncAndMainqueue{
    NSLog(@"----start-----当前线程---%@",[NSThread currentThread]);
    
    //获取主队列
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    // 第一个任务
    dispatch_async(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第一个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第二个任务
    dispatch_async(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第二个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第三个任务
    dispatch_async(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第三个任务---当前线程%@",[NSThread currentThread]);
    });
    
    NSLog(@"----end-----当前线程---%@",[NSThread currentThread]);
    
}
```
* 输出结果：
 ![](https://ws2.sinaimg.cn/large/006tNc79gy1fpa1ii2uhwj31ei04wjt4.jpg)
  
* 总结：所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然异步执行具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）,在主线程中执行完一个任务，再执行下一个任务,按照1>2>3顺序执行，遵循FIFO原则。

###### 同步执行 & 主队列（在主线程中会crash)：

```
-(void)syncAndMainqueue{
    NSLog(@"----start-----当前线程---%@",[NSThread currentThread]);
    
    //获取主队列
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    // 第一个任务
    dispatch_sync(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第一个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第二个任务
    dispatch_sync(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第二个任务---当前线程%@",[NSThread currentThread]);
    });
    
    // 第三个任务
    dispatch_sync(queue, ^{
        
        //这里线程暂停2秒,模拟一般的任务的耗时操作
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----执行第三个任务---当前线程%@",[NSThread currentThread]);
    });
    
    NSLog(@"----end-----当前线程---%@",[NSThread currentThread]);    
}

//下面的例子类似：在同一个同步串行队列中，再使用该队列同步执行任务也是会发生死锁。
-(void)syncAndMainqueue1{

    dispatch_queue_t queue1 = dispatch_queue_create("com.test.testQueue", DISPATCH_QUEUE_SERIAL);
    
    dispatch_sync(queue1, ^{
        
        [NSThread sleepForTimeInterval:2];
        
        NSLog(@"----11111-----当前线程%@",[NSThread currentThread]);//到这里就死锁了
        
        dispatch_sync(queue1, ^{
            
            [NSThread sleepForTimeInterval:2];
            
            NSLog(@"----22222---当前线程%@",[NSThread currentThread]);
        });
        
        NSLog(@"----333333-----当前线程%@",[NSThread currentThread]);
        
    });
    NSLog(@"----44444-----当前线程%@",[NSThread currentThread]);
}
    
```
* 输出结果：
 ![](https://ws4.sinaimg.cn/large/006tNc79gy1fpa1itxjj6j31hc0oaq5r.jpg)
 
 
* 总结:直接crash。这是因为发生了死锁，在gcd中，禁止在主队列(串行队列)中再以同步操作执行主队列任务。同理，在同一个同步串行队列中，再使用该队列同步执行任务也是会发生死锁。

###### 同步执行 & 主队列（在其它线程中）：

```
-(void)othersyncAndMainqueue{
    
    NSLog(@"----start-----当前线程---%@",[NSThread currentThread]);
    
    dispatch_queue_t queue = dispatch_queue_create("com.test.testQueue", DISPATCH_QUEUE_SERIAL);
    
    // 第一个任务
    dispatch_async(queue, ^{
        
        NSLog(@"----执行任务---%@",[NSThread currentThread]);
        
        //获取主队列
        dispatch_queue_t queue = dispatch_get_main_queue();
        
        // 第一个任务
        dispatch_sync(queue, ^{
            
            //这里线程暂停2秒,模拟一般的任务的耗时操作
            [NSThread sleepForTimeInterval:2];
            
            NSLog(@"----执行第一个任务---当前线程%@",[NSThread currentThread]);
        });
    });
    NSLog(@"----end-----当前线程---%@",[NSThread currentThread]);
    
}
```
* 输出结果：
 ![](https://ws3.sinaimg.cn/large/006tNc79gy1fpa0w1vxkyj31eg03y3zu.jpg)

* 总结：所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在主队列中的任务，都会放到主线程中执行）。在主线程中执行完一个任务，再执行下一个任务,按照1>2>3顺序执行，遵循FIFO原则。

参考资料：

 * [iOS多线程：『GCD』详尽总结）](https://juejin.im/post/5a90de68f265da4e9b592b40)
 * Objective-C 高级编程 iOS 与 OS X 多线程和内存管理









